<!DOCTYPE html><html><head><meta charset="utf-8"><style>/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Source Han Sans CN, Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 900px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/
h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1, h2, h3, h4, h5, h6 {
  /*margin: 0px 0px 0px 0px;*/
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
}

h1 {
  /*border-bottom: 3px solid #ccc;*/
  /*border-top: 1px solid #ccc;*/
  background-color: #AEDD81;
  padding: 10px 0px 10px 0px;
  font-size: 28px;
  color: #000;
  text-align: center; 
}

h2 {
  background-color: #B2C8BB;
  padding: 5px 0px 5px 10px;
  font-size: 24px;
  color: #000;
}

h3 {
  background-color: #99ccff;
  padding: 5px 0px 5px 20px;
  font-size: 18px;
  color: #000;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

pre {
  background-color: #1a181f;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; 
}

pre code, pre tt {
  color: #00ff00;
  background-color: transparent;
  border: none;
}

pre code.cmd {
  color: #FFff00;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/
table {
  margin: 0 auto;
  border-collapse:collapse; /* 关键属性：合并表格内外边框(其实表格边框有2px，外面1px，里面还有1px哦) */ 
  border:solid #999; /* 设置边框属性；样式(solid=实线)、颜色(#999=灰) */ 
  border-width:1px 0 0 1px; /* 设置边框状粗细：上 右 下 左 = 对应：1px 0 0 1px */ 
}
table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}


/* IMAGES
=============================================================================*/

img {
  max-width: 95%;
  clear: both;
  display: block;
  margin:auto; 
  margin-top:5px;
  margin-bottom:30px;
  /*
  border-top:1px solid #ccc;   
  border-right:1px solid #666;   
  border-bottom:2px solid #999;   
  border-left:1px solid #ccc;   
  padding: 4px;  
  */
}
.alignleft {
  display: inline;
  float: left;
}

.alignright {
  display: inline;
  float: right;
}

.aligncenter {
  clear: both;
  display: block;
  margin:auto;
} 
</style><title>README</title></head><body><article class="markdown-body"><h1>Git 聊天入门</h1>

<p><strong>Git 可以很复杂，Git 也可以很简单。</strong></p>
<p>读一本Git的书和读一篇Git的文章给人的知识含量是不同的，但给人的愉悦感也是迥异的。本文不想写成一本书，至少不想让你有读书的感觉，但也不想像一篇文章似的只给你一个git的知识点。本文只是想从实际使用的角度，让大家都掌握 git 最简单，但又最有用的那些知识点。—— 因为本来这些问题都是来自于我和朋友们的聊天，可以说是我们的闲聊集，哪会有什么高深的理论？</p>
<p>git 有自己的 <a href="https://www.kernel.org/pub/software/scm/git/docs/user-manual.html">user manunal</a>，如果你读来无碍，请忽视本文，本文与它们相比只是个小人书、连环画。</p>
<hr />
<!-- MarkdownTOC -->

<ul>
<li><a href="#round-1">Round 1</a><ul>
<li><a href="#git">git在哪里</a></li>
<li><a href="#git-for-windows">Git for Windows 咋用</a></li>
<li><a href="#git_1">先单机玩玩还是先弄来个别人的git库</a></li>
<li><a href="#git_2">如何在本机git我的日记</a></li>
<li><a href="#addcommitstatus">每次都要敲add、commit、status，嫌累了</a></li>
<li><a href="#git_3">有些文件不希望被git管理</a></li>
</ul>
</li>
<li><a href="#round-2">Round 2</a><ul>
<li><a href="#git-log">我要筛选 git log</a></li>
<li><a href="#git-log_1">觉得 git log 中的时间看着困难，精简下呗</a></li>
<li><a href="#git-log_2">我要定制 git log，不想一页看不了几条</a></li>
<li><a href="#onelinehashauthordatemessage">oneline太简陋了，我想一行里面看到hash、author、date、message</a></li>
<li><a href="#git-log_3">git log 已经很好了，但好像还是缺点啥</a></li>
<li><a href="#git-log-fuller-author-commit">git log &ndash;fuller 中的 author 和 commit 啥关系</a></li>
</ul>
</li>
<li><a href="#round-3">Round 3</a><ul>
<li><a href="#tortoisesvndiff">我要能像TortoiseSVN那样左右两栏对比看diff</a></li>
<li><a href="#ubuntugit-commint">我用ubuntu，我要修改git commint时的默认编辑器</a></li>
<li><a href="#gitstage">听说git的提交是到什么暂存区（stage），是个什么意思</a></li>
<li><a href="#branch">我想做个分支（branch），怎么做</a></li>
<li><a href="#_1">如何在分支间来回切换</a></li>
<li><a href="#merge">merge是怎么玩儿的</a></li>
<li><a href="#merge_1">分支要合并到主干或其他分支，怎么merge</a></li>
<li><a href="#git-merge">git merge 有没有图形化的工具</a></li>
</ul>
</li>
<li><a href="#round-4">Round 4</a><ul>
<li><a href="#git_4">想看看别人的git库了</a></li>
<li><a href="#github">为什么github成了程序员的麦加圣地</a></li>
<li><a href="#github_1">公司访问不了外网的github，咋办</a></li>
<li><a href="#remoteproxy">定义了外网和内网两个remote，proxy怎么同时支持</a></li>
<li><a href="#_2">如何与别人合作</a></li>
<li><a href="#github_2">如何在github上与别人合作</a></li>
<li><a href="#git_5">怎样才能第一时间得知git上有提交和更新</a></li>
<li><a href="#cloneremote-repolog">如何不clone到本地看remote repo的log?</a></li>
<li><a href="#commitpush">程序猿如何频繁地commit，但又低调地push</a></li>
<li><a href="#_3">远程分支的操作</a></li>
<li><a href="#_4">维持树的整洁</a></li>
<li><a href="#git_6">Git多用户间协作还有什么引人入胜之处</a></li>
</ul>
</li>
<li><a href="#round-5">Round 5</a><ul>
<li><a href="#git_7">git从何而来</a></li>
<li><a href="#git_8">git去往何处</a></li>
<li><a href="#git_9">git有哪些好的入门的资料</a></li>
<li><a href="#git_10">git命令我掌握的七七八八了，怎么整理一下</a></li>
<li><a href="#git_11">重新梳理git的软件</a></li>
</ul>
</li>
<li><a href="#round-6">Round 6</a><ul>
<li><a href="#logrepo">导出某个子目录及其log成为一个新的repo</a></li>
<li><a href="#2bug1commit">分支2需改bug，但我正在分支1上编码并不想commit怎么办</a></li>
<li><a href="#_5">我反悔了，我要回退！</a></li>
</ul>
</li>
<li><a href="#round-7">Round 7</a><ul>
<li><a href="#gitsvn">git和SVN在元数据存储上有什么区别</a></li>
<li><a href="#git-object">git 的对象（object）</a></li>
<li><a href="#git_12">git 的快照存储有点不可思议，如何做到好又多的</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->

<hr />
<h1 id="round-1"><a name="user-content-round-1" href="#round-1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Round 1</h1>
<p><img alt="" src="img/run-buffalo.jpg" /></p>
<h2 id="git"><a name="user-content-git" href="#git" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>git在哪里</h2>
<ul>
<li>Unix系（Ubuntu/Fedora/MAC-OS.X/……）默认就有，打开terminal，输入<code>git --version</code>，就在那里了</li>
<li>Windows上要安装：<a href="https://github.com/git-for-windows/git">Git for Windows</a><ul>
<li>提供我们团队FTP的下载链接：<a href="ftp://emb:zteemb@10.9.111.222/Soft/Develop/Git/Git4Windows/Git-2.7.0-32-bit.exe">Git-2.7.0-32-bit.exe</a></li>
</ul>
</li>
</ul>
<h2 id="git-for-windows"><a name="user-content-git-for-windows" href="#git-for-windows" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Git for Windows 咋用</h2>
<p>一路“下一步”安装完即可。</p>
<p><img alt="" src="img/git4windows-install.png" /></p>
<ol>
<li>Git Bash: Linux 风格的命令行，如： /user/bin</li>
<li>Git CMD： Windows风格的命令行，即：C:\system</li>
<li>Git GUI: 图形化界面</li>
<li>其实还有一个： ${安装目录}/bin/sh.exe —— 我喜欢直接用这个</li>
</ol>
<p><img alt="" src="img/git4windows-sh.png" /></p>
<p>对比一下1和4：</p>
<p><img alt="" src="img/git4windows-gitbash.png" /><br />
<img alt="" src="img/git4windows-bin.png" /></p>
<ul>
<li>1和4的图标不同，4其实是Windows自身的cmd窗口</li>
<li>4由于是Windows自身cmd窗口，所以对中文支持较好</li>
</ul>
<p>所以建议您直接用4：<strong>直接双击或在cmd中打开 ${安装目录}/bin/sh.exe 来运行MinGW环境和git</strong></p>
<h2 id="git_1"><a name="user-content-git_1" href="#git_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>先单机玩玩还是先弄来个别人的git库</h2>
<p>先单机玩玩吧，理由如下：</p>
<p>git 和 svn 最大的区别：</p>
<ul>
<li>svn是集中式管控：所有库（repo）的内容都在server上，离了server连 svn log 都看不了，更别说提交代码了</li>
<li>git是分布式管控：每个git项目里面的.git文件夹中都包括了所有的库（repo）内容，可以看log、提交代码、创建分支、打tag……<ul>
<li>两台电脑的git库之间是<strong>同步（sync）</strong>的概念，大家都是平等的</li>
</ul>
</li>
</ul>
<p>所以说我们还是先练习一下除了sync之外的基础命令吧，会了这些之后，至少你能在本机快乐的写日记了。</p>
<blockquote>
<p>我看到有些小伙伴还在用类似EDiary等日记本软件或PIM软件来写每天的日记，积累了这么多年的日记，一旦win10上运行不了EDiary可咋整？还是赶紧试试用纯文本+Markdown来写日记，用git本地做版本管理吧！</p>
</blockquote>
<p>下文我使用个人日记的小项目来演示本机的git操作</p>
<h2 id="git_2"><a name="user-content-git_2" href="#git_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>如何在本机git我的日记</h2>
<p>OK，让我们从头开始，跟着做一遍吧，Good Luck ……</p>
<ul>
<li>做一下git要求的最基本的两个配置：name 和 email<br />
<pre><code class="cmd">$ git config --global user.name wkevin
$ git config --global user.emal wkevin27@gmail.com
</code></pre></li>
<li>创建一个文件夹并写一篇日记<br />
<pre><code class="cmd">MBP:demo wangkevin$ mkdir mydiary
MBP:demo wangkevin$ cd mydiary
$ cat &gt;diary.md
# Diary

## 2016.1.31
回家过年^C
$ ls
diary.md
$ cat diary.md 
# Diary

## 2016.1.31
回家过年
</code></pre></li>
<li><code>git init</code>:在文件夹中创建git库<br />
<pre><code class="cmd">$ git init
Initialized empty Git repository in /Users/wangkevin/workspace/kproject/demo/mydiary/.git/
</code></pre></li>
<li>和SVN有.svn类似，git也有.git<br />
<pre><code class="cmd">$ ls -a
.       ..      .git        diary.md
$ ls .git
HEAD        config      hooks       objects
branches    description info        refs
$ cat .git/config
[core]
    repositoryformatversion = 0
    filemode = true
    bare = false
    logallrefupdates = true
    ignorecase = true
    precomposeunicode = true
</code></pre></li>
<li><code>git status</code>：显示一个未被管控的文件(Untracked files) diary.md<br />
<pre><code class="cmd">$ git status
On branch master

Initial commit

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

    diary.md

nothing added to commit but untracked files present (use &quot;git add&quot; to track)
</code></pre></li>
<li><code>git add filename</code>：将文件纳入管理，filename 支持通配符，最常用的就是点(.)表示所有文件<br />
<pre><code class="cmd">$ git add diary.md 
</code></pre></li>
<li><code>git status</code> 显示此文件待提交（to be committed），此时文件已经开始被git管理了，文件进入一种暂存状态（stage），如果想反悔可以用<code>git rm --cached</code>使其进入unstage状态<br />
<pre><code class="cmd">$ git status
On branch master

Initial commit

Changes to be committed:
  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)

    new file:   diary.md
</code></pre></li>
<li><code>git status -s</code> -short 短模式<br />
<pre><code class="cmd">$ git status -s
A  diary.md
</code></pre></li>
<li><code>git status -b</code> -branch 显示分支，<code>git status</code>不带参数默认就是-b的，所以常和短模式合作，合并为一个sb，哈哈<br />
<pre><code class="cmd">$ git status -sb
## Initial commit on master
A  diary.md
</code></pre></li>
<li><code>git commit</code>: 将文件从暂存态提交入库 —— 暂存就像回收站（删除前给你一个check的机会，多次操作放入回收站的文件可以一次清空），多次操作放入暂存，最后考虑成熟了，check OK了，再commit提交<br />
<pre><code class="cmd">$ git commit
[master (root-commit) 14dd781] create mydiary
 1 file changed, 4 insertions(+)
 create mode 100644 diary.md
</code></pre></li>
<li>执行 <code>git commit</code> 后会自动打开一个编辑器（编辑器是可配置的，以后再说怎么配置），比如 vi，进行提交log的撰写，保存退出即提交成功，不保存退出即放弃提交<br />
<pre><code class="vi">  1 
  2 # Please enter the commit message for your changes. Lines starting
  3 # with '#' will be ignored, and an empty message aborts the commit.
  4 # On branch master
  5 #
  6 # Initial commit
  7 #
  8 # Changes to be committed:
  9 #   new file:   diary.md
 10 #
</code></pre></li>
<li>再查<code>git status</code>，都已经提交干净了<br />
<pre><code class="cmd">$ git status
On branch master
nothing to commit, working directory clean
$ git status -s
</code></pre></li>
<li>现在可以看log了<br />
<pre><code class="cmd">$ git log
commit 14dd7815fcf56c961e11c52e96e2fc3fbd7d0543
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   Sun Jan 31 11:39:55 2016 +0800

    create mydiary
</code></pre></li>
<li>git 和 svn 不同，没有一个数字递增的节点号，而是一串40Bytes的哈希字符，指定一个提交只需要给出这个字符串即可，当然不能让你每次都把40个字符全输入一遍，只需要输入够区分提交的即可（一般是前7位），如果咱的库规模还很小，前4位也行哦（下文中的“6784”）<br />
<pre><code class="cmd">$ git lg
 b81373d | 2016-01-31 15:49:08 +0800 | 2016-01-31 15:49:08 +0800 |  wkevin  add .gitignore file
 67840e1 | 2016-01-31 12:20:26 +0800 | 2016-01-31 12:20:26 +0800 |  wkevin  2.2日记
 bf36ab9 | 2016-01-31 12:19:33 +0800 | 2016-01-31 12:19:33 +0800 |  wkevin  2.1的日记
 14dd781 | 2016-01-31 11:39:55 +0800 | 2016-01-31 11:39:55 +0800 |  wkevin  create mydiary
$ git log 6784
commit 67840e1813af1084abd5d07d2e2a2e185c679f09
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   Sun Jan 31 12:20:26 2016 +0800

    2.2日记

</code></pre></li>
<li>每天可以随时写日记、随时<code>git add</code>、适时<code>git commit</code>，经过一段时间，你的diary库就越来越让你爱不释手了<br />
<pre><code class="cmd">$ git log
commit 67840e1813af1084abd5d07d2e2a2e185c679f09
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   Sun Jan 31 12:20:26 2016 +0800

    2.2日记

commit bf36ab9b0d489a2eda911be9e01bddc395fc29e0
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   Sun Jan 31 12:19:33 2016 +0800

    2.1的日记

commit 14dd7815fcf56c961e11c52e96e2fc3fbd7d0543
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   Sun Jan 31 11:39:55 2016 +0800

    create mydiary
</code></pre></li>
<li>觉得<code>git log</code>默认显示的内容不爽？想看更详细的、或更简略的？——别急，统统没问题，各种参数全方位满足你的各种需求，但这里先不说，后文慢慢来，先不要用这些复杂的参数来打击自己吧，不过来个一步简洁到位的的命令：<code>git shortlog</code> —— 什么？太简洁了？哈哈，别急，从简洁到纸到复杂到翔全都有，慢慢来。<br />
<pre><code class="cmd">$ git shortlog
wkevin (3):
      create mydiary
      2.1的日记
      2.2日记
</code></pre></li>
</ul>
<p>如果只是做个<strong>日记本</strong>，自己写、自己看、绝不给别人看、绝不上网……这些命令就差不多够了！</p>
<p>哇！好累啊，可以休息一下了，就这些命令，玩几天，把日记写上一个礼拜，然后我们再继续。如果你不打算继续了，也没关系，这些命令就写日记&ndash;够用了！</p>
<h2 id="addcommitstatus"><a name="user-content-addcommitstatus" href="#addcommitstatus" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>每次都要敲add、commit、status，嫌累了</h2>
<p>用git写了一些日记，你肯定有了新需求，能回来接着读说明你是个积极追求上进的好同学，我们继续聊！</p>
<p>有这样的问题说明你已经是git的初级用户了，并且听了我的建议：“使用命令行，远离GUI” —— 我一点都不奇怪，绝大部分程序猿一旦用上git都会上瘾的，会频繁的<code>git commit</code>，然后在<code>git log</code>中寻觅自己的成就感，否则吃不好饭、睡不好觉……呵呵</p>
<p>言归正传。</p>
<p>别名（alias）是linux系统的基本概念，在git中也如鱼得水：</p>
<ul>
<li>这样设置别名<br />
<pre><code class="cmd">$ git config --global alias.st  &quot;status&quot;
</code></pre></li>
<li>然后就可以这样操作了<br />
<pre><code class="cmd">$ git st
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   diary.md

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre></li>
<li>换个别名玩玩<br />
<pre><code class="cmd">$ git config --global alias.st  &quot;status -sb&quot;
$ git st
## master
 M diary.md
</code></pre></li>
<li>把让你烦的命令都用2个字来别名一下吧。比如：<br />
<pre><code class="cmd">$ git config --global alias.ci  &quot;commit&quot;
</code></pre></li>
</ul>
<h2 id="git_3"><a name="user-content-git_3" href="#git_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>有些文件不希望被git管理</h2>
<p>问：markdown写的 diary.md ，会在本地生成 diary.html 检查和欣赏一下，但其实是不需要 commit 的，如何在 <code>git commit</code> 的时候忽略它们。</p>
<p>答：<code>git commit</code>的时候已经不能忽略了，要忽略需要在<code>git add</code>的时候，通过编辑<strong>.gitignore文件</strong>让add命令忽略它们。</p>
<ul>
<li>diary.html 就是我们不想提交的过程文件<br />
<pre><code class="cmd">$ git st
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   diary.md

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

    diary.html

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre></li>
<li>手工生成一个<strong>.gitignore</strong>的文件，写入含有通配符的文件名（即：后缀名为html的文件）<br />
<pre><code class="cmd">$ cat &gt;.gitignore
*.html
^C
$ cat .gitignore 
*.html
</code></pre></li>
<li>diary.html 已经被自动忽略。<br />
<pre><code class="cmd">$ git st
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   diary.md

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

    .gitignore

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre></li>
</ul>
<h1 id="round-2"><a name="user-content-round-2" href="#round-2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Round 2</h1>
<p><img alt="" src="img/gray-owl-mouse-sw.jpg" /></p>
<h2 id="git-log"><a name="user-content-git-log" href="#git-log" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>我要筛选 git log</h2>
<ul>
<li>可以只看某个子目录或某个文件的log</li>
<li>可以从某个提交开始看<br />
<pre><code class="cmd">$ git log 6784
commit 67840e1813af1084abd5d07d2e2a2e185c679f09
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   Sun Jan 31 12:20:26 2016 +0800

    2.2日记
</code></pre></li>
<li>可以只看某个人的log<br />
<pre><code class="cmd">$ git log --author=wkevin
commit 67840e1813af1084abd5d07d2e2a2e185c679f09
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   Sun Jan 31 12:20:26 2016 +0800

    2.2日记
……
</code></pre></li>
<li>&ndash;author 支持匹配<br />
<pre><code class="cmd">$ git log --author=wke
commit 67840e1813af1084abd5d07d2e2a2e185c679f09
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   Sun Jan 31 12:20:26 2016 +0800

    2.2日记
……
</code></pre></li>
<li>&ndash;author 的一个错误匹配<br />
<pre><code class="cmd">$ git log --author=wken
$ 
</code></pre></li>
<li>&ndash;author 上使用通配符<br />
<pre><code class="cmd">$ git log --author=wke.*n
commit 67840e1813af1084abd5d07d2e2a2e185c679f09
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   Sun Jan 31 12:20:26 2016 +0800

    2.2日记
</code></pre></li>
</ul>
<h2 id="git-log_1"><a name="user-content-git-log_1" href="#git-log_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>觉得 git log 中的时间看着困难，精简下呗</h2>
<ul>
<li>使用 &ndash;date=short<br />
<pre><code class="cmd">$ git log --pretty=medium --date=short
commit 67840e1813af1084abd5d07d2e2a2e185c679f09
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   2016-01-31

    2.2日记

commit bf36ab9b0d489a2eda911be9e01bddc395fc29e0
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   2016-01-31

    2.1的日记

commit 14dd7815fcf56c961e11c52e96e2fc3fbd7d0543
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   2016-01-31

    create mydiary
</code></pre></li>
</ul>
<h2 id="git-log_2"><a name="user-content-git-log_2" href="#git-log_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>我要定制 git log，不想一页看不了几条</h2>
<p>默认的<code>git log</code>一条commit log至少需要6行来显示，一页顶多看个5、6条，很不方便。如果单条达到10行的话，一页也就看个2、3条。像linux这样的项目，经常遇到长篇大论的log，内容倒是详实了，但很难做一览表式的查询。</p>
<p>下面我们祭出 git log 的必杀技： &ndash;pretty 或 &ndash;format</p>
<p><code>git log --pretty=xxx</code> 等价于 <code>git log --format=xxx</code>, xxx 可以是这些：</p>
<ul>
<li>oneline：只显示一行</li>
<li>short</li>
<li>medium</li>
<li>full</li>
<li>fuller：会看到有两个角色：author（作者） 和 commit（提交人）</li>
<li>email</li>
<li>raw</li>
<li>format:&rsquo;......&rsquo;</li>
</ul>
<p>其中<code>oneline</code>能够帮你精简log</p>
<pre><code class="cmd">$ git log --pretty=oneline
67840e1813af1084abd5d07d2e2a2e185c679f09 2.2日记
bf36ab9b0d489a2eda911be9e01bddc395fc29e0 2.1的日记
14dd7815fcf56c961e11c52e96e2fc3fbd7d0543 create mydiary
</code></pre>

<p>其实 <code>--oneline</code> 也是一个单独的参数</p>
<pre><code class="cmd">$ git log --oneline
67840e1 2.2日记
bf36ab9 2.1的日记
14dd781 create mydiary
</code></pre>

<h2 id="onelinehashauthordatemessage"><a name="user-content-onelinehashauthordatemessage" href="#onelinehashauthordatemessage" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>oneline太简陋了，我想一行里面看到hash、author、date、message</h2>
<p>那需要用上 &ndash;pretty=formate:&rdquo;......&rdquo;参数了</p>
<p>format 参数很多，没必要逐一掌握，除了你是强迫症患者 &ndash; 凑巧本文不使用强迫症的视角，哈哈</p>
<p>我常用的有：</p>
<ul>
<li>%h：commit hash</li>
<li>%ai: author date</li>
<li>%an: author name</li>
<li>%ci: commit date</li>
<li>%cn: commit name</li>
<li>%s: log message</li>
</ul>
<p>示例：</p>
<ul>
<li>只看日期、作者、log（专业术语是：subject）<br />
<pre><code class="cmd">$ git log --pretty=format:'%ad %an %s'
Sun Jan 31 15:49:08 2016 +0800 wkevin add .gitignore file
Sun Jan 31 12:20:26 2016 +0800 wkevin 2.2日记
Sun Jan 31 12:19:33 2016 +0800 wkevin 2.1的日记
Sun Jan 31 11:39:55 2016 +0800 wkevin create mydiary
</code></pre></li>
<li>日期太碍眼，精简一下<br />
<pre><code class="cmd">$ git log --pretty=format:'%ad %an %s' --date=short
2016-01-31 wkevin add .gitignore file
2016-01-31 wkevin 2.2日记
2016-01-31 wkevin 2.1的日记
2016-01-31 wkevin create mydiary
</code></pre></li>
<li>不好了，但太精简了，咋只有date，没有time<br />
<pre><code class="cmd">$ git log --pretty=format:'%ad %an %s' --date=local
Sun Jan 31 15:49:08 2016 wkevin add .gitignore file
Sun Jan 31 12:20:26 2016 wkevin 2.2日记
Sun Jan 31 12:19:33 2016 wkevin 2.1的日记
Sun Jan 31 11:39:55 2016 wkevin create mydiary
</code></pre></li>
<li>commit hash 最好也能加上<br />
<pre><code class="cmd">$ git log --pretty=format:'%h %ad %an %s' --date=local
b81373d Sun Jan 31 15:49:08 2016 wkevin add .gitignore file
67840e1 Sun Jan 31 12:20:26 2016 wkevin 2.2日记
bf36ab9 Sun Jan 31 12:19:33 2016 wkevin 2.1的日记
14dd781 Sun Jan 31 11:39:55 2016 wkevin create mydiary
</code></pre></li>
</ul>
<p>最后，你还需这样：<br />
<pre><code class="cmd">$ git config --global --replace-all alias.lg   &quot;log --pretty=format:'%h %ad %an %s' --date=local&quot;
</code></pre></p>
<h2 id="git-log_3"><a name="user-content-git-log_3" href="#git-log_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>git log 已经很好了，但好像还是缺点啥</h2>
<p>那就是颜色了，加上颜色让字段分的更加清晰</p>
<pre><code class="cmd">git config --global --replace-all alias.lg  &quot;log --pretty=format:'%C(auto) %h | %ai | %Cred %an %Cgreen %s'&quot;
</code></pre>

<p><img alt="" src="img/git-lg-with-color.png" /></p>
<p>为什么改用<code>%ai</code>，不用<code>%ad</code>了？<br />
<code>%ad</code>会受到<code>--date=xxx</code>的影响，<code>%ai</code>不会。所以限制了<code>%ad</code>的使用，如果常从github上拿代码，会看到世界各地的提交人和提交时间，我还是希望分一下时区的，所以用了<code>%ai</code>。</p>
<p>比如我们来查看linux的源码：</p>
<p><img alt="" src="img/git-lg-by-linux.png" /></p>
<h2 id="git-log-fuller-author-commit"><a name="user-content-git-log-fuller-author-commit" href="#git-log-fuller-author-commit" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>git log &ndash;fuller 中的 author 和 commit 啥关系</h2>
<p>必须要说了，git的设计者的设计思路是：希望提交人（执行<code>git commit</code>的人）能够把author写明白，而不是据为己有。所以git的作者（author）和提交人（commit）可以不是同一个人。</p>
<pre><code class="cmd">$ git commit --author=wkevin --date='2016-01-30 22:04:04 +0800'
</code></pre>

<p>上面的命令可以在commit的同时指定提交内容的author和AUTHOR_DATE，这个恐怕要靠提交者（committer）的记忆力和公德心了，把这段代码真实author的名字和写就时间录进去，而不是让git默认的把自己的name和提交时间（COMMITTER_DATE）录入库中。</p>
<p>在没有github之前，一个开源项目通常还是只设置几个有权限的提交人，大家想贡献代码就发patch给有权限的人，然后有权人commit。但自从有了github，发明了fork（fork并不属于git，而是github的独创哦）和PR（Pull-Request），让这个过程更加的轻便，也让项目的发展更加《失控》，有能力的人可以在自己的领地fork并发展一个项目，PR或不PR给原作者全凭个人喜好，原作者如果“懒政”，其他人完全可以独立发展。—— 每个人都在自己的库里commit，使得committer和author通常都是一个人，大家都是通过PR给其他人，而不是发送patch了。—— 所以 <code>--author</code> 这个参数已经很久不用一次了。</p>
<h1 id="round-3"><a name="user-content-round-3" href="#round-3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Round 3</h1>
<p><img alt="" src="img/boy-buffaloes-india-sw.jpg" /></p>
<h2 id="tortoisesvndiff"><a name="user-content-tortoisesvndiff" href="#tortoisesvndiff" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>我要能像TortoiseSVN那样左右两栏对比看diff</h2>
<p>这个必须有！</p>
<blockquote>
<p>git和TortoiseSVN相比是不恰当的，git要和subversion比较，它们两个是协议；TortoiseGit才是和TortoiseSVN比较，这两个是前端。Subversion的前端并不多，除了TortoiseSVN并没有更多的选择，git的前端却不少：TortoiseGit、GitForWindows、Github for Desktop……</p>
<p>前端对协议进行了封装（比如默认安装的TortoiseSVN都已经找不到<code>svn</code>等命令，所以也不能运行<code>svn log</code>、<code>svn commit</code>）和更多的图形化工作（图标重绘、文本比较工具……）的事情留在后面慢慢说，回到比较工具上来：除非你是要制作补丁包，或者改动很小，否则你几乎不会想直接查看<code>git diff</code>，配置好第三方比较工具的调用方法是必须要做的 —— 这个懒偷不得。</p>
<p>git 调用第三方工具是灵活的，当然TortoiseSVN调用第三方diff/Merge工具也是可定制的，并且用户不指定第三方工具的话，TortoiseSVN项目自己做了一个比较工具TortoiseMerge来作为默认，TortoiseGit也是有默认的。git则需要手工设置。</p>
</blockquote>
<p><strong>git中查看差异有两个命令</strong>:</p>
<ol>
<li><code>git diff</code>: 在Terminal中按照Linux的传统方式生成patch<br />
<img alt="" src="img/git-diff.png" /></li>
<li><code>git difftool</code>: 使用第三方工具显示差异<br />
<img alt="" src="img/git-difftool-merge.png" />       </li>
</ol>
<p><code>git difftool</code> 命令能够调用的第三方比较工具有很多，列几个本人用过的：</p>
<ul>
<li>收费的<ul>
<li><a href="http://www.scootersoftware.com">Beyond Compare</a> &ndash; Win、Linux、OS.X</li>
<li><a href="http://www.araxis.com">Araxis Merge</a> &ndash; Win、OS.X</li>
<li><a href="http://www.ultraedit.com/products/ultracompare.html">UltraCompare</a> &ndash; Win,本来是UE的一个插件，近几年独立出来了</li>
</ul>
</li>
<li>免费但不开源的<ul>
<li><a href="http://www.sourcegear.com/diffmerge/downloads.php">DiffMerge</a> &ndash; Win、Linux、OS.X</li>
</ul>
</li>
<li>开源的：<ul>
<li><a href="http://meldmerge.org">Meld</a> &ndash; Win、Linxu、OS.X</li>
</ul>
</li>
</ul>
<p>用哪个呢？这是萝卜白菜的事情，不要纠结，你用惯了哪个就是哪个（我相信你的电脑上肯定已经有了一个文本比较工具，用它就是了，本着开放、开源、和跨平台的原则，我个人推荐Meld）。git调用它们的方法配置是大同小异。我不能每种软件在每个系统中都试一遍，所以只能条目列在这里，但我本人没搞过的就空着了，看官自己百度一下吧，照葫芦画瓢能力强的话也用不着百度。</p>
<ul>
<li><strong>Araxis Merge</strong><ul>
<li>OS.X: <code>vi ~/.gitconfig</code>，加入：<br />
<pre><code>difftool.prompt=false
diff.tool=araxis
merge.tool=araxis
mergetool.araxis.path=/Applications/Araxis Merge.app/Contents/Utilities/compare
difftool.araxis.path=/Applications/Araxis Merge.app/Contents/Utilities/compare
</code></pre></li>
<li>Linux</li>
<li>Windows</li>
</ul>
</li>
<li><strong>BeyondCompare</strong><ul>
<li>OS.X</li>
<li>Linux</li>
<li>Windows<br />
<pre><code class="cmd">$ git config --global diff.tool bc3
$ git config --global difftool.bc3.path &quot;c:/program files/beyond compare 3/bcomp.exe&quot;
</code></pre></li>
</ul>
</li>
<li><strong>DiffMerge</strong><ul>
<li>OS.X</li>
<li>Linux</li>
<li>Windows<br />
<pre><code class="cmd">$ git config --global diff.tool diffmerge
$ git config --global difftool.diffmerge.cmd 'diffmerge &quot;$LOCAL&quot; &quot;$REMOTE&quot;'
</code></pre></li>
</ul>
</li>
<li><strong>Meld</strong><ul>
<li>OS.X</li>
<li>Linux</li>
<li>Windows</li>
</ul>
</li>
</ul>
<p>除此之外，还可以配置一项：</p>
<pre><code class="cmd">$ git config --global difftool.prompt false 
</code></pre>

<p>OK，弄好了吧，我们来总结一下其知识点，如果不想看，可以跳过去看下条了。</p>
<ul>
<li>配置方法两种：<ol>
<li>通过 <code>git config ...</code> 命令</li>
<li>通过 <code>vi ~/.gitconfig</code> 直接修改git的配置文件，方法1最终也是落实到2上</li>
</ol>
</li>
<li>配置命令有两个：<ol>
<li>cmd：git在执行某个difftool的时候，执行的命令，用户没有定义的话，会使用tool的名字做默认启动；如果用户定义的话，就必须加上 $LOCAL $REMOTE</li>
<li>path: 用于定位不在PATH变量里的命令，但不需要加 $LOCAL $REMOTE</li>
</ol>
</li>
</ul>
<p>肯定还是有些完美主义者，一台电脑上安装了多个比较软件，想要不断切换 —— 也是没问题的。</p>
<ul>
<li>可以配置多个cmd<br />
<pre><code class="cmd">$ git config --global difftool.bc.cmd 'beyondcompare &quot;$LOCAL&quot; &quot;$REMOTE&quot;'
$ git config --global difftool.am.cmd 'araxismerge &quot;$LOCAL&quot; &quot;$REMOTE&quot;'
$ git config --global difftool.dm.cmd 'diffmerge &quot;$LOCAL&quot; &quot;$REMOTE&quot;'
</code></pre></li>
<li>根据需求随时切换<br />
<pre><code class="cmd">$ git config --global diff.tool bc
</code></pre><br />
或<br />
<pre><code class="cmd">$ git config --global diff.tool am
</code></pre><br />
或<br />
<pre><code class="cmd">$ git config --global diff.tool dm
</code></pre></li>
</ul>
<h2 id="ubuntugit-commint"><a name="user-content-ubuntugit-commint" href="#ubuntugit-commint" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>我用ubuntu，我要修改git commint时的默认编辑器</h2>
<pre><code class="cmd">ubuntu$ update-alternatives --config editor
</code></pre>

<p>这个问题不属于git的范畴，而是linux的。</p>
<h2 id="gitstage"><a name="user-content-gitstage" href="#gitstage" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>听说git的提交是到什么暂存区（stage），是个什么意思</h2>
<p>理解git需要理解文件的5种状态和3个区（area）：</p>
<p>5种状态：</p>
<ol>
<li>未跟踪态（untracked）</li>
<li>未修改状态（unmodified）</li>
<li>修改状态（modified），即：待暂存（staging）</li>
<li>已暂存（staged）</li>
<li>已提交（committed）</li>
</ol>
<p>3个区：</p>
<ol>
<li>本地工作目录（working directory）</li>
<li>暂存区（staging area，又叫做index）</li>
<li>git库（repository）</li>
</ol>
<p>1、2、3状态在本地工作目录，4状态属于暂存区，5状态属于git库。</p>
<p><img alt="" src="img/git-state-and-area.svg" /></p>
<p>如果我修改了一下README.md，<code>git add</code>了一下，然后又修改了一下，用<code>git st</code>的打印是这样的：</p>
<pre><code class="cmd">$ git st
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    modified:   README.md

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   README.md
</code></pre>

<p>很多地方把暂存和stage混在一起，不查字典的话还以为stage的中文翻译就是暂存。其实 stage 就这个单词的本身的意思是：</p>
<ol>
<li>名词：舞台、讲台，比如：戏剧表演的舞台、国际政治的舞台；阶段，类似phase，比如：stage one/two意思是第一/二阶段，three-stage rocket意思是三级火箭</li>
<li>动词：上演、举行、组织，类似play、organize，比如：stage a football match，举办足球赛</li>
</ol>
<p>stage本身并没有暂存的意思，git中可以理解为把文件放到一个舞台上上演一下，进而文件进入到一个新的阶段。——用这个词可以说是一箭三雕。</p>
<p>你可以输入<code>git help stage</code> 看看</p>
<pre><code class="cmd">GIT-STAGE(1)                                              Git Manual                                              GIT-STAGE(1)
NAME
       git-stage - Add file contents to the staging area
SYNOPSIS
       git stage args...
DESCRIPTION
       This is a synonym for git-add(1). Please refer to the documentation of that command.
</code></pre>

<p><code>git stage</code> 是同义于 <code>git add</code> 的：将文件加入到 <strong>staging area</strong>（舞台区、阶段区、进而翻译为暂存区，下文我还是尽量不去翻译这个词汇，而直接用英文吧，或搞个缩写：SA —— 如果让我翻译，我会译为：检视区）。</p>
<p>把前面已经提到过暂存区像回收站，把文件放在回收站是给操作人一个检视的机会和反悔的机会，操作妥当后再彻底删除，彻底删除后再想反悔就要费劲了。git的staging area也是给用户一个<strong>检视的机会</strong>和<strong>反悔的机会</strong>，用户可以：</p>
<ul>
<li>使用<code>git add</code>或<code>git stage</code>命令随时向SA增加文件，和回收站不同的是后进入SA的文件会覆盖前面进入的</li>
<li>使用<code>git checkout</code>命令随时从SA反悔，文件会从SA移除，是否覆盖</li>
</ul>
<h2 id="branch"><a name="user-content-branch" href="#branch" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>我想做个分支（branch），怎么做</h2>
<p>好了，这里要提到一个非常重要的概念了，很多git书籍都会强调的一点：<strong>git的branch只是个指针</strong> —— 也常被称作“<strong>git的必杀技</strong>”。</p>
<p>git 的分支操作异常的迅速、便捷、和轻量级，全部依赖于branch只是个指针，类似于C语言的指针，但这个指针不是4Bytes，而是包含了比较多的信息（算是个struct吧，呵呵），通常书里是这样描述此指针的：</p>
<pre><code class="cmd">MBP:GitChat.git wangkevin$ git br
* master                12205fd [origin/master] 写完 “## 我要能像TortoiseSVN那样左右两栏对比看diff”章节
  remotes/origin/master 12205fd 写完 “## 我要能像TortoiseSVN那样左右两栏对比看diff”章节
MBP:GitChat.git wangkevin$ git lg
 12205fd | 2016-02-04 00:50:37 +0800 | 2016-02-04 00:50:37 +0800 |  wkevin  写完 “## 我要能像TortoiseSVN那样左右两栏对比看diff”章节
 8216a0b | 2016-02-02 23:55:44 +0800 | 2016-02-02 23:55:44 +0800 |  wkevin  基本写完 Round 2 ，git log 部分
 8674466 | 2016-01-31 16:22:59 +0800 | 2016-01-31 16:22:59 +0800 |  wkevin  在动车上写的：修改为Round x，增加了每个Round的插图。 虽然是春运，但动车上并不挤，卧改座的还能躺着睡觉，坐票也有些车厢人很少。 还有2h下车，提交一下，休息休息。
 ac580f2 | 2016-01-30 22:04:04 +0800 | 2016-01-30 22:04:04 +0800 |  wkevin  github desktop for windows snapshot
 de9a9ab | 2016-01-29 17:51:48 +0800 | 2016-01-29 17:51:48 +0800 |  Kevin Wang  add git for windows 章节
 e59757f | 2016-01-29 10:35:01 +0800 | 2016-01-29 10:35:01 +0800 |  Kevin Wang  增加：&quot;git在哪里&quot;和&quot;git for windows 咋用&quot; 章节
 7aa77c3 | 2016-01-29 09:40:52 +0800 | 2016-01-29 09:40:52 +0800 |  Kevin Wang  create
MBP:GitChat.git wangkevin$ git fetch origin
remote: Counting objects: 6, done.
remote: Compressing objects: 100% (5/5), done.
remote: Total 6 (delta 2), reused 5 (delta 1), pack-reused 0
Unpacking objects: 100% (6/6), done.
From https://github.com/wkevin/GitChat
   12205fd..c242093  master     -&gt; origin/master
MBP:GitChat.git wangkevin$ git br
* master                12205fd [origin/master: behind 2] 写完 “## 我要能像TortoiseSVN那样左右两栏对比看diff”章节
  remotes/origin/master c242093 笔误
MBP:GitChat.git wangkevin$ git lg origin/master
 c242093 | 2016-02-04 11:30:21 +0800 | 2016-02-04 11:30:21 +0800 |  wkevin  笔误
 48eda25 | 2016-02-04 11:21:57 +0800 | 2016-02-04 11:21:57 +0800 |  wkevin  笔误: 缺少一个反括号
 12205fd | 2016-02-04 00:50:37 +0800 | 2016-02-04 00:50:37 +0800 |  wkevin  写完 “## 我要能像TortoiseSVN那样左右两栏对比看diff”章节
 8216a0b | 2016-02-02 23:55:44 +0800 | 2016-02-02 23:55:44 +0800 |  wkevin  基本写完 Round 2 ，git log 部分
 8674466 | 2016-01-31 16:22:59 +0800 | 2016-01-31 16:22:59 +0800 |  wkevin  在动车上写的：修改为Round x，增加了每个Round的插图。 虽然是春运，但动车上并不挤，卧改座的还能躺着睡觉，坐票也有些车厢人很少。 还有2h下车，提交一下，休息休息。
 ac580f2 | 2016-01-30 22:04:04 +0800 | 2016-01-30 22:04:04 +0800 |  wkevin  github desktop for windows snapshot
 de9a9ab | 2016-01-29 17:51:48 +0800 | 2016-01-29 17:51:48 +0800 |  Kevin Wang  add git for windows 章节
 e59757f | 2016-01-29 10:35:01 +0800 | 2016-01-29 10:35:01 +0800 |  Kevin Wang  增加：&quot;git在哪里&quot;和&quot;git for windows 咋用&quot; 章节
 7aa77c3 | 2016-01-29 09:40:52 +0800 | 2016-01-29 09:40:52 +0800 |  Kevin Wang  create
MBP:GitChat.git wangkevin$ 
</code></pre>

<h2 id="_1"><a name="user-content-_1" href="#_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>如何在分支间来回切换</h2>
<p>概要：</p>
<ul>
<li><code>git checkout file</code>：用暂存区的file覆盖工作区的file</li>
<li><code>git checkout branch</code>：HEAD指向branch，然后去覆盖暂存区和工作区</li>
<li><code>git checkout --detach branch</code>：游离指向branch，然后去覆盖暂存区和工作区</li>
<li><code>git checkout commit</code>：游离指向commit，，然后去覆盖暂存区和工作区</li>
<li><code>git checkout branch/commit file</code>：那指针指向的file去覆盖暂存区和工作区的file，所以暂存区会有待提交内容</li>
</ul>
<p>详细：</p>
<ul>
<li><code>git checkout &lt;./file&gt;</code><ul>
<li>HEAD 不会切换</li>
<li>用暂存区的file覆盖工作区中对应的文件，暂存区的不变<ul>
<li><strong>如果没有未提交的修改，暂存区和HEAD是相同的</strong></li>
<li>如果暂存区刚才有未提交的修改，后续仍可commit</li>
</ul>
</li>
<li>覆盖：意味着所有修改会丢失；但新增的文件不丢失。</li>
</ul>
</li>
<li><code>git checkout &lt;branch&gt;</code><ul>
<li>HEAD 会被切换</li>
<li>用 <branch> 中的文件覆盖工作区中对应的文件</li>
<li>切换的当前branch时：本地修改不会丢失，也不必提交</li>
<li>切换的其他branch时：本地修改要先提交，-f 强切修改会丢失</li>
</ul>
</li>
<li><code>git checkout --detach [&lt;branch&gt;]</code><ul>
<li>HEAD 不变<ul>
<li><code>git checkout --detach</code>：会从当前 HEAD 创建游离指针</li>
<li><code>git checkout --detach anotherBranch</code>：会从 anotherBranch 指针创建游离指针</li>
</ul>
</li>
<li>从<branch>处创建一个<strong>游离</strong>的branch，并覆盖到本地工作区</li>
<li>从当前branch创建游离分支时：本地修改不会丢失，也不必提交</li>
<li>从其他branch创建游离分支时：本地修改要先提交，-f 强切修改会丢失</li>
</ul>
</li>
<li><code>git checkout [--detach] &lt;commit&gt;</code><ul>
<li>游离一个branch</li>
</ul>
</li>
<li><code>git checkout [[-b|-B|--orphan] &lt;new_branch&gt;] [&lt;start_point&gt;]</code></li>
</ul>
<h2 id="merge"><a name="user-content-merge" href="#merge" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>merge是怎么玩儿的</h2>
<h2 id="merge_1"><a name="user-content-merge_1" href="#merge_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>分支要合并到主干或其他分支，怎么merge</h2>
<p>merge有几个场景，按场景来学习更带劲：</p>
<ul>
<li>本地工作目录是branch1的，希望从branch2合并过来，branch1和branch1从同一个节点继承，branch2比branch1多了若干次提交<ul>
<li>branch1在继承节点后没有修改</li>
<li>branch1在继承节点后有修改但没有暂存</li>
<li>branch1在继承节点后有修改并且都暂存了，但还没有提交</li>
<li>branch1在继承节点后有修改却只有一部分暂存了</li>
<li>branch1在继承节点后有提交，无暂存态和修改态的文件</li>
</ul>
</li>
<li></li>
</ul>
<h2 id="git-merge"><a name="user-content-git-merge" href="#git-merge" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>git merge 有没有图形化的工具</h2>
<p>和 <code>git difftool</code> 类似，也有 <code>git mergetool</code>。</p>
<ul>
<li>通用配置<br />
<pre><code class="cmd">$ git config --global mergetool.diffmerge.trustExitCode true
</code></pre></li>
<li><strong>BeyondCompare</strong><ul>
<li>OS.X</li>
<li>Linux</li>
<li>Windows<br />
<pre><code class="cmd">$ git config --global merge.tool bc3
$ git config --global mergetool.bc3.path &quot;c:/program files/beyond compare 3/bcomp.exe&quot;
$ git mergetool
</code></pre></li>
</ul>
</li>
<li><strong>DiffMerge</strong><ul>
<li>OS.X</li>
<li>Linux</li>
<li>Windows<br />
<pre><code class="cmd">$ git config --global merge.tool diffmerge
$ git config --global mergetool.diffmerge.cmd 'diffmerge --merge --result=&quot;$MERGED&quot; &quot;$LOCAL&quot; &quot;$(if test -f &quot;$BASE&quot;; then echo &quot;$BASE&quot;; else echo &quot;$LOCAL&quot;; fi)&quot; &quot;$REMOTE&quot;'
</code></pre></li>
</ul>
</li>
</ul>
<h1 id="round-4"><a name="user-content-round-4" href="#round-4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Round 4</h1>
<p><img alt="" src="img/children-dam-bali-sw.jpg" /></p>
<h2 id="git_4"><a name="user-content-git_4" href="#git_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>想看看别人的git库了</h2>
<p>是不是已经不满足于只管理个本机的日记了？太好了，git天生就是为了程序猿合作用的，几条关键的命令要出场了：</p>
<ul>
<li><code>git clone url [localname]</code>  </li>
</ul>
<h2 id="github"><a name="user-content-github" href="#github" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>为什么github成了程序员的麦加圣地</h2>
<h2 id="github_1"><a name="user-content-github_1" href="#github_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>公司访问不了外网的github，咋办</h2>
<pre><code class="cmd">$ git config --global http.proxy http://&lt;proxyserver&gt;:&lt;port&gt;
$ git config --global https.proxy http://&lt;proxyserver&gt;:&lt;port&gt;
</code></pre>

<p>实战：</p>
<ul>
<li>没有配置proxy时，提示连不上github<br />
<pre><code class="cmd">$ git clone https://github.com/wkevin/GitChat.git GC
Cloning into 'GC'...
fatal: unable to access 'https://github.com/wkevin/GitChat.git/': Failed to connect to github.com port 443: Timed out
</code></pre></li>
<li>配置proxy<br />
<pre><code class="cmd">$ git config --global http.proxy http://proxysz.zte.com.cn:80
$ git config --global https.proxy http://proxysz.zte.com.cn:80
</code></pre></li>
<li>写错url（https为http），提示url错误<br />
<pre><code class="cmd">$ git clone http://github.com/wkevin/GitChat.git GC
Cloning into 'GC'...
fatal: unable to access 'http://github.com/wkevin/GitChat.git/': The requested URL returned error: 502
</code></pre></li>
<li>写对url，还是提示错误——这个就不应该了，看来是proxy出问题了<br />
<pre><code class="cmd">$ git clone https://github.com/wkevin/GitChat.git GC
Cloning into 'GC'...
fatal: unable to access 'https://github.com/wkevin/GitChat.git/': Received HTTP code 502 from proxy after CONNECT
</code></pre></li>
<li>喝了杯茶，回来再试<br />
<pre><code class="cmd">$ git clone https://github.com/wkevin/GitChat.git GC
Cloning into 'GC'...
remote: Counting objects: 64, done.
remote: Compressing objects: 100% (5/5), done.
remote: Total 64 (delta 0), reused 0 (delta 0), pack-reused 59
Unpacking objects: 100% (64/64), done.
Checking connectivity... done.
</code></pre></li>
</ul>
<h2 id="remoteproxy"><a name="user-content-remoteproxy" href="#remoteproxy" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>定义了外网和内网两个remote，proxy怎么同时支持</h2>
<p>自己的某个项目有两个remote：Ra和Rb，分别在外网和公司内网，为git配置了http.proxy后，外网OK，内网的就连不上，则内网的remote可以使用ssh来连接。</p>
<p>网上通常的步骤是：</p>
<ul>
<li>生成公钥和密钥<br />
<pre><code class="cmd">$ ssh-keygen -t rsa -C &quot;wkevin27@gmail.com&quot;
</code></pre><ul>
<li>得到两个文件：id_rsa和id_rsa.pub</li>
<li><strong>请确定两个文件的路径</strong>：git for windows 有时候生成的文件会位于：<code>C:\ShellHome</code>，而<code>git push</code>等命令使用的是用户根目录，这两个目录未必一致，可能会被用户无意间修改。</li>
</ul>
</li>
<li>拷贝公钥到github/gitlab<ul>
<li>可打开文件手工拷贝</li>
<li>可 <code>clip &lt; ~/.ssh/id_rsa.pub</code> 拷贝到粘贴板</li>
</ul>
</li>
<li>添加密钥到ssh-agent（可选）<ul>
<li><code>$ eval "$(ssh-agent -s)"</code> </li>
<li><code>$ ssh-add ~/.ssh/id_rsa</code></li>
</ul>
</li>
<li>测试<ul>
<li><code>$ ssh -T git@github.com</code></li>
</ul>
</li>
<li>然后就可以使用ssh方式访问gitlab/github了<ul>
<li><code>git remote add xxx git@github.com:wkevin/GitChat.git</code></li>
<li><code>git push xxx master</code></li>
</ul>
</li>
</ul>
<h2 id="_2"><a name="user-content-_2" href="#_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>如何与别人合作</h2>
<h2 id="github_2"><a name="user-content-github_2" href="#github_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>如何在github上与别人合作</h2>
<p>github的工作流： <a href="https://guides.github.com/introduction/flow/">Understanding the GitHub Flow</a></p>
<h2 id="git_5"><a name="user-content-git_5" href="#git_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>怎样才能第一时间得知git上有提交和更新</h2>
<p>和团队成员保持紧密合作在敏捷中非常重要，SVN的时候有一个非常优秀的软件 CommitMonitor，能够监控SVNServer的更新，图标是一双大眼睛，悄悄的躲在任务栏，发现更新大眼睛变成红色转啊转的。</p>
<p>git和svn有所不同，svn 有 server，监控器只需要监控server即可，git 没有server，只有hub，或者说每个人电脑里的git都是server，大家通过hub进行同步。监控server和监控hub的思路是有些差别的，各位看官可细细品味。</p>
<p>监控 git hub 的软件有：</p>
<ul>
<li>windows 平台<ul>
<li>SourceLog：<a href="https://github.com/tomhunter-gh/SourceLog">https://github.com/tomhunter-gh/SourceLog</a></li>
<li>SCM Notifier： <a href="https://github.com/pocorall/scm-notifier">https://github.com/pocorall/scm-notifier</a></li>
</ul>
</li>
<li>linux 平台<ul>
<li>GitMon：<a href="https://github.com/spajus/gitmon">https://github.com/spajus/gitmon</a></li>
<li>git-dude： <a href="https://github.com/sickill/git-dude">https://github.com/sickill/git-dude</a></li>
<li>git-notifier： <a href="http://www.icir.org/robin/git-notifier">http://www.icir.org/robin/git-notifier</a></li>
</ul>
</li>
<li>OS.X 平台<ul>
<li>Gitifier：<a href="https://github.com/nschum/Gitifier">https://github.com/nschum/Gitifier</a></li>
</ul>
</li>
</ul>
<p>但经过我的试用，功能还都不完善，希望它们早日成熟、好用。</p>
<p>目前可以使用 github/gitlab 的 RSS Feed 功能：</p>
<p>针对个人的RSS Feed：<br />
<img alt="" src="img/gitlab-rss-feed-user.png" /></p>
<p>针对团队的RSS Feed：<br />
<img alt="" src="img/gitlab-rss-feed-group.png" /></p>
<p>使用 RSS Reader（图中使用的是Snafer）订阅的效果：<br />
<img alt="" src="img/gitlab-rss-reader.png" /></p>
<h2 id="cloneremote-repolog"><a name="user-content-cloneremote-repolog" href="#cloneremote-repolog" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>如何不clone到本地看remote repo的log?</h2>
<h2 id="commitpush"><a name="user-content-commitpush" href="#commitpush" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>程序猿如何频繁地commit，但又低调地push</h2>
<p>SVN和git面对同样的一个问题：大部分程序猿是含蓄、内敛的，他既希望频繁的commit，让svn/git帮他记住每一步，但并不想把这些过程信息全都公诸于众，而只是把阶段性成果推送给大家或服务器。</p>
<p>具体情况还要分为两种：假定两名程序员A、B</p>
<ol>
<li>A、B负责的代码耦合性不高，或A、B不相互依赖<ul>
<li><a href="http://codecampo.com/topics/379?comment_id=1354#comment-1354">构造干净的 Git 历史线索</a></li>
</ul>
</li>
<li>A、B负责的代码耦合性高，或A、B相互依赖<ul>
<li>需求：协同开发：调试期间多人之间代码依赖，相互调用，使用头文件……</li>
<li>设计：用SVN也可以协同开发，但会在服务器上留下大量无效的调试记录</li>
<li>操作：git方式：<strong>将本机库开放给同伴，合作开发完成后使用 git rebase -i 清理</strong><ul>
<li>准备<ul>
<li>A君<ul>
<li>.git目录下新建git-daemon-export-ok文件，表明该工程允许非授权访问<ul>
<li>cd /path/to/project.git</li>
<li>touch git-daemon-export-ok</li>
</ul>
</li>
<li>git daemon &ndash;reuseaddr &ndash;base-path=/opt/git/ /opt/git/</li>
<li>告诉B君你的IP</li>
</ul>
</li>
<li>B君<ul>
<li>git checkout git://your_ip_address/project</li>
</ul>
</li>
</ul>
</li>
<li>调试过程<ul>
<li>A君快乐的随意本机修改并git commit</li>
<li>B君随时随地的git pull</li>
</ul>
</li>
<li>调试完成后<ul>
<li>A君<ul>
<li>git rebase -i将本地的提交进行清理</li>
<li>将一次记录git push到服务器上</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="_3"><a name="user-content-_3" href="#_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>远程分支的操作</h2>
<ul>
<li>删除本地分支</li>
<li>删除远程分支<ul>
<li>git push origin :<branchName></li>
<li>git push origin &ndash;delete <branchName></li>
</ul>
</li>
<li>删除本地tag<ul>
<li>git tag -d <tagname></li>
</ul>
</li>
<li>删除远程tag<ul>
<li>git tag -d <tagname></li>
<li>git push origin :refs/tags/<tagname></li>
<li>git push origin &ndash;delete tag <tagname></li>
</ul>
</li>
<li>删除“远程已经删除了的分支”对应的本地分支：<strong>git fetch -p</strong></li>
</ul>
<h2 id="_4"><a name="user-content-_4" href="#_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>维持树的整洁</h2>
<p><a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a> </p>
<p>方法就是：在git push之前，先git fetch，再git rebase</p>
<p>git rebase（衍合）</p>
<p>git rebase 一般自己一个人开发时使用，用来保持提交记录的整洁。一旦上传到github后，不应该使用git rebase,不然被骂死。</p>
<p>一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。<br />
 如果你遵循这条金科玉律，就不会出差错。否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p>
<h2 id="git_6"><a name="user-content-git_6" href="#git_6" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Git多用户间协作还有什么引人入胜之处</h2>
<ul>
<li>集中式工作流<br />
<img alt="" src="img/workflow.onecore.png" /></li>
<li>集成管理员工作流<br />
<img alt="" src="img/workflow.manager.png" /></li>
<li>司令与副官流程（Linux）<br />
<img alt="" src="img/workflow.many.layers.png" /></li>
</ul>
<h1 id="round-5"><a name="user-content-round-5" href="#round-5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Round 5</h1>
<p><img alt="" src="img/elephants-sand-river-sw.jpg" /></p>
<h2 id="git_7"><a name="user-content-git_7" href="#git_7" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>git从何而来</h2>
<p><img alt="" src="img/Torvalds.jpg" /></p>
<p>这里有一篇git的创始人Torvalds（同时也是Linux的创始人）的接受中国媒体的一篇访谈录：</p>
<ul>
<li><a href="http://www.wtoutiao.com/a/2287349.html">Linux创始人Linus Torvalds访谈，Git的十年之旅</a> &ndash; 如果网页链接失效，重新百度即可，Torvalds接受类似的访谈录很多，但大多是英文的。</li>
</ul>
<h2 id="git_8"><a name="user-content-git_8" href="#git_8" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>git去往何处</h2>
<p>2005年7月26日开始，Torvalds把git托付给了一位日本人：<a href="https://en.wikipedia.org/wiki/Junio_Hamano">Junio Hamano</a>。Torvalds也说过自己一生最大的成功之一就包括把git托付给Hamano。</p>
<p>Hamano现在google，他的github帐号为：<a href="https://github.com/gitster">gitster</a>，头像中抱着个大熊猫，说不定比较喜欢China哦。<br />
<img alt="" src="img/Hamano.jpg" /></p>
<p>git源码的<a href="https://github.com/git/git/graphs/contributors">提交统计</a>中可以发现Hamano是提交最踊跃的：</p>
<p><img alt="" src="img/git-contributors.png" /></p>
<p>github上有这样几个卓越的组织（Orgnization):</p>
<ul>
<li><a href="https://github.com/git">git</a>:目前有<a href="https://github.com/orgs/git/people">8位成员</a>，牵头人 <a href="https://github.com/schacon">Scott Chacon</a>，他们充当管理者和传教士的角色，比较重要的贡献是：<ul>
<li>维护git源码<ul>
<li>Hamano(gitster)并没有加入到这个Orgnization中，而只是fork到自己账号下，然后PR到 git/git，看来gitster只是想当程序员，不想当管理者和传教士——大概源于日本人和中国人类似，都比较低调。</li>
</ul>
</li>
<li>管理和维护 <a href="http://git-scm.com">git-scm.com</a> 网站</li>
</ul>
</li>
<li><a href="https://github.com/progit">progit</a>:目前有<a href="https://github.com/orgs/progit/people">位成员</a>，牵头人 <a href="https://github.com/schacon">Scott Chacon</a> 和 <a href="https://github.com/ben">Ben Straub</a>，两人目前都供职于github公司，比较重要的贡献有<ul>
<li>写了《Pro git》这本书，此书被翻译成多种语言，被奉为经典。</li>
</ul>
</li>
</ul>
<h2 id="git_9"><a name="user-content-git_9" href="#git_9" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>git有哪些好的入门的资料</h2>
<p>读到这里是需要系统的了解、学习一下git的时候了，<br />
当然，我明白你说的是中文资料。</p>
<ul>
<li>Pro Git:根正苗红的书<ul>
<li><a href="http://git-scm.com/book/en/v2">英文版-v2</a></li>
<li><a href="http://git-scm.com/book/zh/v2">中文版-v2</a>，<a href="http://www.kancloud.cn/kancloud/progit">国内备份</a></li>
<li><a href="http://git-scm.com/book/zh/v1">中文版-v1</a>， <a href="http://git.oschina.net/progit/">国内备份</a></li>
</ul>
</li>
<li><a href="http://gitbook.liuhui998.com/index.html">Git Community Book 中文版</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">git简明教程</a></li>
</ul>
<p>但是有时候英文资料是不可避免的：</p>
<ul>
<li><a href="http://git.wiki.kernel.org">git wiki</a></li>
</ul>
<h2 id="git_10"><a name="user-content-git_10" href="#git_10" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>git命令我掌握的七七八八了，怎么整理一下</h2>
<p>google 或 bing 上搜索图片：<strong>git cheat sheet</strong> —— 不要在baidu上搜索，结果你会很失望。</p>
<p>可以看到很多热心网友们整理的常用命令集，快选一幅打印出来或作为桌面吧！</p>
<p>比如（版权归作者所有，本文仅是转发）：</p>
<p><img alt="" src="img/Git-Cheatsheet-1.png" /><br />
<img alt="" src="img/Git-Cheatsheet-3.jpg" /><br />
<img alt="" src="img/Git-Cheatsheet-4.png" /></p>
<p>也有一些复杂到令人发指的：<br />
<img alt="" src="img/Git-Cheatsheet-2.png" /></p>
<h2 id="git_11"><a name="user-content-git_11" href="#git_11" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>重新梳理git的软件</h2>
<p>是时候看一下git的 <a href="https://en.wikipedia.org/wiki/Git_(software)">维基百科</a> 了：</p>
<blockquote>
<p>Git is a widely-used source code management system for software development. It is a distributed revision control system with an emphasis on speed,[6] data integrity,[7] and support for distributed, non-linear workflows.[8] Git was initially designed and developed in 2005 by Linux kernel developers (including Linus Torvalds) for Linux kernel development.[9]</p>
<p>As with most other distributed version control systems, and unlike most client–server systems, every Git working directory is a full-fledged repository with complete history and full version-tracking capabilities, independent of network access or a central server.[10] Like the Linux kernel, Git is free software distributed under the terms of the GNU General Public License version 2.</p>
</blockquote>
<ul>
<li>UI前端也有，比如github出品的 <a href="https://desktop.github.com">github desktop</a></li>
<li><a href="https://github.com/git-for-windows/git">Git for Windows</a><br />
        * 第一代的名字叫<a href="https://github.com/msysgit/git">msysGit</a>，基于 msys（属于 MinGW）—— 2015年底已废弃<br />
        * 第二代重新建立了github项目<a href="https://github.com/git-for-windows/git">Git for Windows</a>，基于 msys2（不再属于MinGW），英语有自信的可以读读它的<a href="https://github.com/git-for-windows/git/wiki">背景</a><ul>
<li><a href="http://code.google.com/p/tortoisegit/">TortoiseGit</a>：类似TortoiseSVN，可以做图标重绘。</li>
</ul>
</li>
</ul>
<h1 id="round-6"><a name="user-content-round-6" href="#round-6" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Round 6</h1>
<p><img alt="" src="img/black-trevally-sardines-sw.jpg" /></p>
<h2 id="logrepo"><a name="user-content-logrepo" href="#logrepo" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>导出某个子目录及其log成为一个新的repo</h2>
<pre><code>cd oldrepo
git subtree split -P subdir -b newbranch
gitk newbranch

mkdir ../newrepo.git
cd ../newrepo.git
git init
git config --bool core.bare true

cd ../oldrepo
git push ../newrepo.git newbranch:master #newrepo.git is a pure repo without my files

cd ..
git clone newrepo.git
</code></pre>

<h2 id="2bug1commit"><a name="user-content-2bug1commit" href="#2bug1commit" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>分支2需改bug，但我正在分支1上编码并不想commit怎么办</h2>
<p>使用git的时候，我们往往使用branch解决任务切换问题，例如，我们往往会建一个自己的分支去修改和调试代码, 如果别人或者自己发现原有的分支上有个不得不修改的bug，我们往往会把完成一半的代码 commit提交到本地仓库，然后切换分支去修改bug，改好之后再切换回来。这样的话往往log上会有大量不必要的记录。其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急Bug，那么使用&rsquo;git stash&rsquo;就可以将你当前未提交到本地（和服务器）的代码推入到Git的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修 Bug，等到修完Bug，提交到服务器上后，再使用&rsquo;git stash apply&rsquo;将以前一半的工作应用回来。也许有的人会说，那我可不可以多次将未提交的代码压入到栈中？答案是可以的。当你多次使用&rsquo;git stash&rsquo;命令后，你的栈里将充满了未提交的代码，这时候你会对将哪个版本应用回来有些困惑，&rsquo;git stash list&rsquo;命令可以将当前的Git栈信息打印出来，你只需要将找到对应的版本号，例如使用&rsquo;git stash apply stash@{1}&rsquo;就可以将你指定版本号为stash@{1}的工作取出来，当你将所有的栈都应用回来的时候，可以使用&rsquo;git stash clear&rsquo;来将栈清空。</p>
<ul>
<li>git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。</li>
<li>git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。</li>
<li>git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。</li>
<li>git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。</li>
<li>git stash apply：将以前一半的工作应用回来</li>
</ul>
<h2 id="_5"><a name="user-content-_5" href="#_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>我反悔了，我要回退！</h2>
<p>丢弃（要懂得放弃）</p>
<ul>
<li><code>git clean -df</code>：丢弃untracked的文件，不丢弃modified的文件</li>
<li><code>git checkout .</code>：用缓存或HEAD中的文件覆盖本地文件，这些文件中的修改都丢弃掉了，但新增的文件不会被丢弃</li>
<li>git stash #把所有没有提交的修改暂存到stash里面。可用git stash pop回复。</li>
<li>git reset &ndash;soft HASH #返回到某个节点。保留修改</li>
<li>git reset &ndash;hard HASH #返回到某个节点，不保留修改。<ul>
<li>git reset &ndash;hard HEAD</li>
<li>git reset &ndash;hard HEAD~1</li>
<li>git reset &ndash;hard HEAD~5</li>
<li></li>
</ul>
</li>
<li>git clean -f: 删除 untracked files</li>
<li>git clean -fd: 连 untracked 的目录也一起删掉</li>
<li>git clean -xfd: 连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）</li>
<li>在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删<ul>
<li>git clean -nxfd</li>
<li>git clean -nf</li>
<li>git clean -nfd</li>
</ul>
</li>
</ul>
<p>回退远程</p>
<ol>
<li>git reset &ndash;soft hashcode remoteRepo</li>
<li>把本地的回退了，然后把远程branch删掉，然后push新的</li>
</ol>
<p><strong>git reset</strong></p>
<p><code>git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;…</code><br />
<code>git reset (--patch | -p) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;…]</code><br />
<code>git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [&lt;commit&gt;]</code></p>
<ul>
<li>图中3个动作：<ol>
<li>替换引用的指向。引用指向新的提交ID。</li>
<li>替换暂存区。替换后，暂存区的内容和引用指向的目录树一致。</li>
<li>替换工作区。替换后，工作区的内容变得和暂存区一致，也和HEAD所指向的目录树内容相同。</li>
</ol>
</li>
<li>3个参数：<ul>
<li>&ndash;hard: 执行上图中的全部动作1、2、3</li>
<li>&ndash;soft: 执行上图中的全部动作1</li>
<li>&ndash;mixed:执行上图中的全部动作1、2，—— 默认操作</li>
</ul>
</li>
<li>举例：<ul>
<li><code>git reset</code>==<code>git reset HEAD</code>：用HEAD重置暂存区，工作区不受影响，相当于回滚/撤销 <code>git add</code></li>
<li><code>git reset -- filename</code> == <code>git reset HEAD filename</code>：仅将文件的改动撤出暂存区，暂存区中其他文件不改变。</li>
<li><code>git reset --soft HEAD^</code>：工作区和暂存区不改变，但是HEAD和当前分支引用向前回退一次<ul>
<li>用途：提交了之后，你又发现代码没有提交完整，或者你想重新编辑一下再提交</li>
</ul>
</li>
<li><code>git reset --hard</code> == <code>git reset --hard HEAD</code>: 用HEAD覆盖暂存区和工作区，即：丢弃所有本地修改</li>
</ul>
</li>
<li>重置可以朝前，也可以朝后<br />
    <pre><code>$ git br
* master ecfc106 2
  new    ab3fa01 3
$ git reset --soft new
$ git br
* master ab3fa01 3
  new    ab3fa01 3
</code></pre></li>
</ul>
<h1 id="round-7"><a name="user-content-round-7" href="#round-7" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Round 7</h1>
<h2 id="gitsvn"><a name="user-content-gitsvn" href="#gitsvn" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>git和SVN在元数据存储上有什么区别</h2>
<p>svn是基于增量存储的，两次提交对于repo来说只保存变化量，git不使用svn的增量方式保存数据，而是使用快照。因为git的分布式特性，并没有一颗树一样成长的repo，repo更像是一张网式的成长，节点与节点之间可能会绕很远才能找到亲戚关系，所以增量无从谈起。</p>
<p>来看下面这个过程：</p>
<ul>
<li>A、B两个git clone</li>
<li>A的commit 时间比 B 晚</li>
<li>A先push</li>
<li>B在push时失败，先pull，再次commit</li>
<li>A一次ci，B两次ci —— 比svn多了一次ci，因为svn中B是先merge后ci，git中是先ci后merge再ci</li>
<li>B再push</li>
<li>git log：ci的顺序是：B的ci、A的ci、B的merge后ci —— <strong>B的ci会插入到A的ci前面</strong></li>
</ul>
<p>如果用增量存储，将很难把整个过程记录下来，根本原因是：<strong>开发者提交前是不需要同步别人代码的</strong>。</p>
<h2 id="git-object"><a name="user-content-git-object" href="#git-object" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>git 的对象（object）</h2>
<p><a href="http://gitbook.liuhui998.com/1_2.html">GIT对象模型</a></p>
<ul>
<li>git的指针（branch是指针）指向某个对象（object）</li>
<li>git的object包含4个部分：<ul>
<li>对象名：40bit的HASH</li>
<li>类型：有4种：<ol>
<li>blob</li>
<li>tree</li>
<li>commit</li>
<li>tag</li>
</ol>
</li>
<li>大小：</li>
<li>内容：</li>
</ul>
</li>
<li>可以使用 <code>git show &lt;对象名&gt;</code> 来查看一个object的内容</li>
</ul>
<p>4类object的图示：</p>
<table>
<thead>
<tr>
<th>blob</th>
<th>tree</th>
<th>commit</th>
<th>tag</th>
</tr>
</thead>
<tbody>
<tr>
<td><img alt="" src="img/object-blob.png" /></td>
<td><img alt="" src="img/object-tree.png" /></td>
<td><img alt="" src="img/object-commit.png" /></td>
<td><img alt="" src="img/object-tag.png" /></td>
</tr>
</tbody>
</table>
<p>我的粗浅认识是：</p>
<ul>
<li>blob对象封装了具体的文件，<a href="http://baike.baidu.com/link?url=uwTulBgFwwZkFIksfXQHzCFT1Nrm1U7Eo_3LY-1uZJwl6JYrDETOitmBdJeYKVwVOCLwUnF_0RozRyPHDTvSKK">blob的百度百科</a>，blob单词的意思是一疙瘩、一坨。</li>
<li>tree类似目录、文件夹，包含了tree和blob</li>
<li>commit：包含了一个tree的指针（对象名），和父级commit对象，还有<code>git commit</code>时的相关信息。</li>
<li>tag：指向一个commit对象</li>
</ul>
<p>来实际操作一把：</p>
<ul>
<li><code>git log</code> 找一条commit<br />
<pre><code class="cmd">$ git lg
 e3426a5 | 2016-02-16 11:20:22 +0800 | 2016-02-16 11:20:22 +0800 |  Kevin Wang  调整章节，内容基本没变
 a15f695 | 2016-02-16 10:28:16 +0800 | 2016-02-16 10:28:16 +0800 |  Kevin Wang  增加 git cheat sheet 小节
 c242093 | 2016-02-04 11:30:21 +0800 | 2016-02-04 11:30:21 +0800 |  wkevin  笔误
 48eda25 | 2016-02-04 11:21:57 +0800 | 2016-02-04 11:21:57 +0800 |  wkevin  笔误: 缺少一个反括号
</code></pre></li>
<li><code>git show &lt;object-name&gt;</code> 可以查看各类object的细节</li>
<li><code>git show &lt;commit-object-name&gt;</code> 可以查看 commit 类型的细节，其中包括了diff（即：和parrent父级commit对象相比的差异：tree及其blob的差异）<br />
<pre><code class="cmd">$ git show  e3426a5
commit e3426a51534d97f5c73369a98fd38d6fb2f83f0a
Author: Kevin Wang &lt;wkevin27@gmail.com&gt;
Date:   Tue Feb 16 11:20:22 2016 +0800

    调整章节，内容基本没变

diff --git a/README.md b/README.md
index 17944e2..a0be055 100644
--- a/README.md
+++ b/README.md
@@ -31,21 +31,24 @@ git 有自己的 [user manunal](https://www.kernel.org/pub/software/scm/git/docs
     - [merge是怎么玩儿的](#merge)
 - [Round 4](#round4)
</code></pre></li>
<li><code>git show --pretty=raw &lt;commit-object-name&gt;</code> 还能更多的查看 commit 对象所指向的tree对象<br />
<pre><code class="cmd">$ git show --pretty=raw e3426a5
commit e3426a51534d97f5c73369a98fd38d6fb2f83f0a
tree 65e1673d28da6cf7554cc0bed020673f68276112
parent a15f6954d609da2bebc243a52a8dd1094e6e2fd6
author Kevin Wang &lt;wkevin27@gmail.com&gt; 1455592822 +0800
committer Kevin Wang &lt;wkevin27@gmail.com&gt; 1455592822 +0800

    调整章节，内容基本没变

diff --git a/README.md b/README.md
index 17944e2..a0be055 100644
--- a/README.md
+++ b/README.md
</code></pre></li>
<li><code>git show &lt;tree-object-name&gt;</code> 或 <code>git ls-tree &lt;tree-object-name&gt;</code> 或 <code>git ls-tree &lt;commit-object-name&gt;</code> 都能够看到 tree 对象更多的细节<br />
<pre><code class="cmd">$ git show 65e1673
tree 65e1673

.gitignore
README.md
img/

$ git ls-tree 65e1673
100644 blob 40f51b88ea8b90ff1c9db36ffc45cfd71f71c078    .gitignore
100644 blob a0be0555eeeb50e4702e137a7837ad9970be7755    README.md
040000 tree 5aec0814a9b43d040a1a3388aaf2c4ae60e296f4    img

$ git ls-tree e3426a5
100644 blob 40f51b88ea8b90ff1c9db36ffc45cfd71f71c078    .gitignore
100644 blob a0be0555eeeb50e4702e137a7837ad9970be7755    README.md
040000 tree 5aec0814a9b43d040a1a3388aaf2c4ae60e296f4    img
</code></pre></li>
<li><code>git show &lt;blob-object-name&gt;</code> 查看一个blob对象的细节，如果是文本文件就等同于<code>$cat file</code>了<br />
<pre><code class="cmd">$ git show 40f51b
*.html
.vim.*
</code></pre></li>
</ul>
<h2 id="git_12"><a name="user-content-git_12" href="#git_12" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>git 的快照存储有点不可思议，如何做到好又多的</h2>
<ul>
<li>继续前面的话题，我们往前查几个commit对象，试图发现的更多一些<br />
<pre><code class="cmd">$ git show --pretty=raw 48eda25
commit 48eda255c3f727e57f1462592a8cd8fd8d16839a
tree f1683d3e377fcbb99cca10c481d0070375e1bf23
parent 12205fd2616a0af5ebe8243f6e5c16a64e9e9127
author wkevin &lt;wkevin@users.noreply.github.com&gt; 1454556117 +0800
committer wkevin &lt;wkevin@users.noreply.github.com&gt; 1454556117 +0800

    笔误: 缺少一个反括号
</code></pre></li>
<li>看看这个tree对象包含的内容<br />
<pre><code class="cmd">$ git ls-tree f1683d3e
100644 blob 40f51b88ea8b90ff1c9db36ffc45cfd71f71c078    .gitignore
100644 blob 5211c0dae2ab042cf0cf2edff08809af510e358a    README.md
040000 tree 4867a64660a9d90a8a5a966c9fac1187861762f3    img
</code></pre></li>
</ul>
<p>可以发现两次commit所指向的tree对象中：</p>
<ul>
<li>.gitignore的HASH相同</li>
<li>README.md的HASH不同</li>
</ul>
<p>因此说明：<strong>每次提交仅会把有改动的file重新计算HASH并封装为对象进行存储</strong></p>
<p>整个文件存储那不是很浪费空间？—— Yes！</p>
<p>那为什么还比svn的增量存储更快呢？ —— 这个问题</p></article></body></html>